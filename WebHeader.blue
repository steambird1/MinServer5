# For VBWeb Server
# Automaticly insert

class receiver:
	shared class
	shared attributes
	shared path
	shared http_version
	shared method
	shared content
	shared server_dir

class path_resolver:
	function resolve path:
		set this.args=new dict
		set this.path=""
		set argmode=false
		set mykey=""
		set myvalue=""
		set inkey=true
		for i=0~len path:
			if (path#i)="?":
				set argmode=true
			else:
				if argmode:
					if (path#i)="&":
						set inkey=true
						set this.args:mykey=myvalue
						set mykey=""
						set myvalue=""
					elif (path#i)="=":
						set inkey=false
					else:
						if inkey:
							set mykey=mykey+(path#i)
						else:
							set myvalue=myvalue+(path#i)
				else:
					set this.path=this.path+(path#i)
		set this.args:mykey=myvalue

class post_data:
	init:
		set this.myfile=null
		set this.attributes=null
		set this.name=null
	function open:
		if this.myfile=null:
			return null
		set reader=new binary_reader
		run reader.open this.myfile
		return reader

class sender:
	shared class
	function _setfiles fname:
		set sender.sendname=fname
		set sender.stream=new binary_writer
		set sender.contentin=0
		set sender.finished=0
		run sender.stream.open sender.sendname,1
	function write data:
		if page_mode=1:
			echo data
		else:
			sender.stream.write data
	function writebin binary:
		if page_mode=1:
			raise "Cannot use sender.writebin"
		run sender.stream.write_binary binary
	function write_header server_version response_code response_text:
		if not boolean sender.contentin:
			if page_mode=1:
				echo (server_version+" "+response_code+" "+response_text)
			else:
				sender.write (server_version+" "+response_code+" "+response_text+LF)
	function write_attribute key value:
		if not boolean sender.contentin:
			if page_mode=1:
				echo (key+": "+value)
			else:
				sender.write (key+": "+value+LF)
	function start_html:
		sender.write_header "HTTP/1.1",200,"OK"
		sender.write_attribute "Content-Type","text/html"
	function start_txt:
		sender.write_header "HTTP/1.1",200,"OK"
		sender.write_attribute "Content-Type","text/plain"
	function require_utf:
		if page_mode=1:
			set syncer=new writer
			syncer.open keeper.commander,false,false
			syncer.write ("do_convert"+LF)
			syncer.close
			call __utfcall
		else:
			raise "Cannot use sender.require_utf"
	function start_content:
		if page_mode=1:
			raise "Cannot use sender.start_content"
		if not boolean sender.contentin:
			set sender.contentin=1
			run sender.write LF
	function send_content_str data:
		if page_mode=1:
			raise "Cannot use sender.send_content_str"
		run sender.write_attribute "Content-Length",(len data)
		run sender.start_content
		run sender.write data
		set sender.finished=1

class keeper:
	shared class
	shared data
	function _init fname:
		set keeper.data=new dict
		set keeper.newadder=new list
		set keeper.commander=fname
	function _set key value:
		set keeper.data:key=value
	function sync:
		set syncer=new writer
		syncer.open keeper.commander,false,false
		for i=0~keeper.newadder.length:
			syncer.write ("keep "+(keeper.newadder:i)+"="+(keeper.data:(keeper.newadder:i))+LF)
		syncer.close
	function set key value:
		keeper.newadder.append key
		keeper._set key,value
	function get key:
		return keeper.data:key

# Execution component
set receiver.content=new list
# Normal content generated by server

class __postback_data:
	inherits object

class postback:
	# document and field are reserved!
	shared class
	function _strify obj:
		set data=str obj
		set l=len data
		set res=""
		for i=0~l:
			set ch=data#i
			if ch="^":
				set res=res+"^^"
			elif ch=LF:
				set res=res+"^n"
			elif ch=".":
				set res=res+"^d"
			elif ch=",":
				set res=res+"^c"
			elif ch="=":
				set res=res+"^e"
			elif ch=" ":
				set res=res+"^s"
			else:
				set res=res+ch
		return res
	function get control attrib:
		return postback.data.document:(control+"."+attrib)
	function set control attrib value:
		set ca=control+"."+attrib
		set postback.data.document:ca=value
		if isint value:
			sender.write ("@control_int "+ca+"="+value)
		else:
			sender.write ("@control "+ca+"="+(postback._strify value))
	function set_int control attrib value:
		postback.set control,attrib,(atoi value)
	function set_bool control attrib bool:
		set ca=control+"."+attrib
		set postback.data.document:ca=value
		if boolean bool:
			sender.write ("@control_int "+ca+"=true")
		elif isnull bool:
			sender.write ("@control_int "+ca+"=null")
		else:
			sender.write ("@control_int "+ca+"=false")
	function add_job js_func js_para:
		sender.write ("@job "+js_func+"="+(postback._strify js_para))
	function add_timer name interval blue_call blue_para:
		sender.write ("@timer "+name+"="+interval+","+blue_call+","+(postback._strify blue_para))
	function remove_timer name:
		sender.write ("@timer_remove "+name+"=REMOVE")
	function _inside_process:
		debugger
		if receiver.ispost:
			raise "Incorrect postback form"
		set s=receiver.content.open
		set res=s.read_to_end
		set postback.data=object res
		s.close
		$postback.data.field

class client:
	shared class
	function write data:
		postback.add_job "mins_write",data
	function alert data:
		postback.add_job "mins_alert",data
	function confirm blue_call data:
		postback.add_job "mins_confirm",(blue_call+":"+data)
	function prompt blue_call data:
		postback.add_job "mins_prompt",(blue_call+":"+data)
	function refresh:
		postback.add_job "mins_refresh",""
